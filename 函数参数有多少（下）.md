# 函数参数有多少（下）

接着上篇的内容，本篇文章为大家介绍一下函数参数传递的一些问题和参数类型注解功能。

1. 值传递还是引用传递

   熟悉C/C++的同学一定对这两个词语非常清楚。**值传递**表示参数传递时会拷贝一份实参副本给函数执行，而**引用传递**则传递的是对某个对象的引用。这里对**引用**多做一些解释。Python中每一个对象（一切皆对象）都有一个唯一的值来表示它的身份，这个值可以用`id()`函数获取到。**在CPython实现(CPython是官方标准采用C语言实现的Python）中**，这个身份是由对象的**内存地址**来表示。在Python中，**引用**表示利用一个标识符（其实就是变量名）来指向某个对象。`=`操作符表示引用操作，而非传统意义的赋值运算符。所以当你写了`a = 1 `时，Python做了这样的操作：

   - 在内存某个位置存储了整数`1`，是实实在在的内存空间；
   - 令标识符`a`指向上面`1`的内存地址。

   为了证明这一点，来看下面的说明：

   ```Python
   a = 1
   print(id(a)) # 137282816 
   b = 1
   print(id(b)) # 137282816
   c = a
   print(id(c)) # 137282816
   ```

   可以看到，`a`,`b`,`c`的`id`值均一样，即三者均是同一个对象（数字`1`）的**引用**。为什么`b`和`a`一样呢？因为Python为了降低内存的申请频率，对于相同的**字面量**值，只会在内存中存储一次:

   ```python
   a = 'Python'
   print(id(a)) # 3070827872
   b = 'Python'
   print(id(b)) # 3070827872 和id(a)是一样的
   ```

   列表元素也是对对象的引用：

   ```python
   a = [1, 0, 3]
   b = 2
   a[1] = b
   print(id(a[1])) # 137282832
   print(id(b)) # 137282832
   ```

   其他类型的对象，则会多次分配内存：

   ```python
   a = [1, 2, 3]
   print(id(a)) # 3070411180
   b = [1, 2, 3]
   print(id(b)) # 3070412588
   ```

   你可以用`is`关键字判断两个标识符是否指向了同一个对象（即`id`是否一样）：

   ```python
   a = 1
   b = 1
   print(a is b) # True
   a = [1, 2, 3]
   b = [1, 2, 3]
   print(a is b) # False
   ```

   如果我改变`a`的值，`c`会变吗？

   ```python
   a = 1
   c = a
   print(c is a) # True
   a = 2
   print(c) # 1
   print(c is a) # False
   ```

   总结起来：

   - **字面量常量**在内存中永远只有一份存储，不论在哪里创建了它；
   - 普通**不可变对象**每次创建都会在内存中存储一份，即使它们的内容完全一致，但是**对象中的内容不可被修改**；
   - **可变对象**每次创建都会在内存中存储一份，但是**对象中的内容可以被修改**；

   回到正题，那Python中函数参数传递究竟是**值传递**还是**引用传递**呢。

   - **如果是值传递**，那么变量在函数局部会得到一份拷贝，修改拷贝**不会**影响到函数外的值：

   ```python
   def func1(a):
       a[0] = 1
   
   a = [0 for x in range(3)]
   print(a) # [0, 0, 0]
   func1(a)
   print(a) # [1, 0, 0]
   ```

   看到了吗？变量`a`被修改了，所以**值传递的说法是不准确的**

   - **如果是引用传递**，那么变量在函数局部做修改后**会**影响外部的值，因为传递的是实际对象的地址，经过地址索引后读取到的是原始值。在Python中是这样的吗？其实上面的`a`和`c`已经给出答案了：

   ```python
   def func1(a):
       print(id(a)) # 137282816
       a = 2
       print(id(a)) # 137282832
       
   a = 1
   print(id(a)) # 137282816
   func1(a)
   print(a) # 1
   print(id(a)) # 137282816
   ```

   ​	如果你理解了我前面说的**Python引用**，你应该能理解上面的结果

   - 有人说，Python中存在**可变对象**和**不可变对象**，对**可变对象**采用的引用传递，对**不可变对象**采用值传递，这个说法准确吗？

     其实这个说法和上一个存在的问题类似，都是没有真正理解**Python引用**和传统的**引用**是有区别的。来看一个例子解释这个说法的不准确之处，这里参数传递一个**可变对象**列表：

   ```python
   def func2(a):
       print(id(a)) # 3070412620
       b = a
       b[0] = 1
       print(id(b)) # 3070412620
       b = [1, 2, 3]
       print(id(a)) # 3070412620
       print(id(b)) # 3070411180
   
   a = [0]*3 # a = [0, 0, 0]
   print(id(a)) # 3070412620
   func2(a)
   print(a) # [1, 0, 0]
   print(id(a)) # 3070412620
   ```

   总结起来，**Python中的参数传递方式是对象引用的方式**，由于变量（标识符）本身并不是对象，而是对指向对象的指针的**绑定**，所以在参数传递时，实际上是**用了一个新的标识符绑定到调用参数的标识符所绑定的对象上**，就像前面`c = a`一样。对新的标识符做修改（可变对象才能修改），自然**可以**反映到调用者，因为它们绑定的是同一个对象；令新标识符引用一个新的对象（等号操作符），自然**不会**反映到调用者，因为它是一个**新的标识符**。（好像人名和人的关系一样，Lucy有个外号叫Jane（`Jane = Lucy`），后来它把这个外号给了另一个人做名字（`Jane = Bob`）。如果`Bob`生病了，`Lucy`会生病吗？）

2. 默认参数陷阱

   前一篇文章中讲到了Python**参数默认值**，这里来看一下默认值可能带来的陷阱：

```python
def func3(a=[]):
    a.append(1)
    return a

print(func3()) # [1]
print(func3()) # [1, 1]
```

？？？期望的输出应当是每次调用都输出一个`[1]`，这里怎么了？

这是因为，Python的参数默认值在**函数定义时**就已经生成并存储在内存中了。如果参数是可变对象，那么每次采用默认值调用函数时都会修改内存中已经存在的值（而不是重新生成一个）。

所以当你需要为某个可变对象参数定义一个空值作为默认值，应当这样写：

```python
def func3(a=None):
    if a is None:
        a = []
	a.append(1)        
	return a
print(func3()) # [1]
print(func3()) # [1]
```

3. 类型注解

   在函数定义时，你可以为每个参数及返回值做一些辅助性的注解（像注释一样），来更好的说明参数的类型：

```python
def func4(a: int, b: '这是一个字典', c: True=None) -> list:
    print('a = {}, b = {}, c = {}'.format(a, b, c))
    return c

func4(1, {}) # a = 1, b = {}, c = None
```

​	你可以通过标准库中的`inpsect`模块来获取注解内容：

```python
from inspect import signature
sig = signature(func4)
print(sig) # (a:int, b:'这是一个字典', c:True=None) -> list
print(sig.parameters['b']) # b:'这是一个字典'
print(sig.parameters['c'].annotation) # True
print(sig.return_annotation) # <class 'list'>
```

​	在CPython中，类型注解执行时会被直接忽略掉，**不会做任何类型检查**。如果你**确实确实**想要在Python中做类型检查，可以利用装饰器自己来完成：

```python
def inspector(func):
	def wrapper(*args, **kwargs):
        # Check types here
        # e.g., assert isinstance(kwargs.get('a'), int)
        return func(*args, **kwargs)
    return wrapper

@inspector
def func4(a: int, b: '这是一个字典', c: True=None) -> list:
    pass
```

​	但是在Python中做类型检查是一个很差的想法，这会耗掉你很多的精力并且不会有任何有用的效果。Python是鸭子类型语言，类型检查违背了它动态性原则，仅仅是在很特别的情况下才会有一定的作用。在函数中通常需要的是**具有所需接口的对象**，而非**某种类型的对象**（这两句话有区别吗？）。所以，在函数中你需要的是**检视某个参数是否具有某种功能**而不是**检视某个参数是否是某种类型**。如果你非常非常希望使用类型检查，你应当使用**Java语言**。

**鸭子类型：**当一只鸟（或者随便一个什么东西），它走起来像鸭子，游起来像鸭子，叫起来也像鸭子，那Python认为它就是鸭子，不管它本质上究竟是不是鸭子。进而就可以把它当鸭子来烤或者其他用于真正鸭子的操作。

在Python3.5中，给出了详细的标准类型注解协议，有兴趣可以在PEP 484中看到完整定义。







